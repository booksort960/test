C语言中，有几种基本内置类型。

> int
> unsigned int
> signed int
>
> char
> unsigned char
> signed char
>
> long
> unsigned long
> signed long
>
> float
> double


在内存中创建变量，会在内存中开辟空间，并为其赋值。

> int a = 10;

在计算机中，所有数据都是以二进制的形式存储在内存中。
变量在计算机中有三种表示方式，原码反码，补码。

## 原码
直接将二进制按照正负数的形式翻译成二进制就可以

## 反码
将原码的** 符号位** 不变，其他位依次按位取反就可以得到了

## 补码
反码 + 1就得到补码
对于整型

> int
> char

类型的数据而言，数据存放内存中其实存放的是补码。并且，运算时也是以补码的形式进行运算。
再来了解一下数据在内存中的储存模式。

> 大端存储：，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
> 小端存储：是指数据的低位保存在内存的低地址中，而数据的高位, ，保存在内存的高地址中。

同时要求，数据以什么模式存如内存中，还要以什么顺序拿出。
现在，vs好像都是以小端模式进行存储。
** 来做几道题，去研究数据在内存中的存储**

在原，反，补码中。如果是有符号的第一位，就是符号位，0为正， - 1为负。

```c
#include <stdio.h>
int main()
{
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;
    printf("a=%d,b=%d,c=%d", a, b, c);
    return 0;
}
```
a为 - 1，所有整型，初始认为是int类型，32个二进制位。

> a：10000000 00000000 00000000 00000001 - 原码
> ---- - 11111111 11111111 11111111 11111110 - 反码
> ---- - 11111111 11111111 11111111 11111111 - 补码

在赋给char类型。当然，一切运算都是以补码的形式进行。无论是类型提升，还是截断，都是以补码的形式，只有表示的时候才会回到原码。

> 11111111 11111111 11111111 11111111 - 补码
> 截断 - char型
> 11111111 - a

又要求以 % d打印， * *就需要整型提升，而整型提升要看a这个变量本身的类型。 * ***如果变量是无符号的就补0，有符号的如果符号位是1就补1 * *.这个a是有符号的类型，符号位又是1是个负数，就补符号位1.
> 1111111 111111111 11111111 11111111 - 提升后的补码
> 再有符号的十进制数打印， * *还要看补码的符号位，如果是正数，就原反补相同。**
> 11111111 11111111 11111111 11111110 - 反码。
> 10000000 00000000 00000000 000000001 - 原码
> 在打印就是 - 1

b和a是一样的有符号的都是 - 1。
c是无符号的char但， - 1

> ----10000000 00000000 00000000 00000001 - 原码
> ---- - 11111111 11111111 11111111 11111110 - 反码
> ---- - 11111111 11111111 11111111 11111111 - 补码

再赋给c进行截断。
还是

> 11111111 - 补码

进行整型提升，就要看c，是无符号，则第1个1就是不是符号位。则补0，就行了。

> 00000000 00000000  00000000  11111111 - 补码

再看以什么类型进行打印，有符号整型，再看符号位是0，就代表是正数，就原反补相同。直接打印255.


## 总结一下
1，整型数据，初始时默认int，32个比特位，先变成补码再截断或提升，再赋值给某个类型的变量（原码转反码，符号位不变11）。

2，所有数据在内存中都是以补码的形式进行存储，以及运算，包括各种整型提升与截断。

3，整型提升时，要看该变量的类型，如果是有符号类型，看第一个二进制位符号位，如果符号位是1，就补1，如果是0，就补0。如果变量是无符号类型，就全补0。

4，打印时，要考虑，以什么形式打印。如果是 % d，有符号的十进制进行打印，要看提升后的符号位，如果是1，就代表是负数，要转为原码打印，如果是0，就直接打印（正数原，反，补码都一样）。如果是无符号的打印，就代表其补码代表的就是一个无符号数的补码，则原反补相同，就是补码直接打印。

再来多看几道题

```c
#include <stdio.h>
int main()
{
    char a = -128;
    printf("%u\n", a);
    return 0；
}
```


> a
> 10000000 00000000 00000000 10000000 - 原码
> 111111111 111111111 111111111 011111111 - 反码
> 111111111 111111111 111111111 10000000 - 补码

补码再进行截断

> 10000000

要以无符号十进制进行打印。整型提升

> 111111111 111111111 111111111  10000000

因为是无符号打印，就代表，这个补码代表的是一个无符号数。
直接就是原码。

> 11111111 11111111 11111111  10000000 - 原码

打印为4294967168


```c
#include <stdio.h>
int main()
{
    char a = 128;
    printf("%u\n", a);
    return 0;
    ```
        和上一题一样


>  a
> 10000000 00000000 00000000 10000000 - 原码
> 111111111 111111111 111111111 011111111 - 反码
> 111111111 111111111 111111111 10000000 - 补码

截断后，为 - 10000000
再提升，打印，就还是

> 111111111 111111111 111111111 10000000

直接打印。4294967168

```c
int i = -10;
    unsigned int j = 20;
    printf("%d", i + j);
    ```
        已经说了，所有运算都是以补码的形式进行。

> i
> 00000000 00000000 00000000 00001010 - 原码
> 00000000 00000000 00000000 00001010 - 反码
> 00000000 00000000 00000000 00001010 - 补码

正数原，反，补，相同。

> j
> 10000000 0000000 0000000 00010100 - 原码
> 11111111 11111111 11111111 11101011 - 反码
> 11111111 11111111 11111111 11101100 - 补码

> i + j
> i:00000000 00000000 00000000 00001010
> j:11111111   11111111   11111111   111011 00

结果

> 11111111   11111111   11111111   11111110 - 补码

怎么打印还是要看以什么形式打印， % d有符号打印，就转回原码


> 11111111   11111111   11111111   11110110 - 补码
> 11111111   11111111   11111111   11110101 - 反码
> 10000000 00000000 00000000 00001010 - 原码

结果就是 - 10.


> char
> -128到127


![在这里插入图片描述](https://img-blog.csdnimg.cn/2021013123180250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjE5OTEwOQ==,size_16,color_FFFFFF,t_70)

    再来一题

        ```c
        int main()
    {
        char a[1000];
        int i;
        for (i = 0; i < 1000; i++)
        {
            a[i] = -1 - i;
        }
        printf("%d", strlen(a));
        return 0;
    }
    ```

        ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210131231027248.png)


        >10000000000000000000000010000001 - -129原码
> 11111111111111111111111101111110 - 反码
> 11111111111111111111111101111111 - 补码
> 因为是放进char类型内存，要截断，
> 011111111
> 按照char 类型的补码对比，就是127。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210131233018391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjE5OTEwOQ==,size_16,color_FFFFFF,t_70)
        会是一类循环的数字题目中，从 - 1走到 - 128，再从 - 128到127，再到1，0.
            \0的ASCII码值就是0，再char类型中，0就代表\0。所以会计算255个数。